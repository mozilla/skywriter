commit af519fb170444858ed53d2cd75c734fb5b3ab6ff
Author: Kevin Dangoor <kid@blazingthings.com>
Date:   Tue Oct 26 22:53:35 2010 -0400

    adding more utilities, fixes up types, adding events and settings plugins.
    now reports when plugins are initialized (via a promise)

diff --git a/plugins/events/lib/index.js b/plugins/events/lib/index.js
new file mode 100644
index 0000000..a9e9aec
--- /dev/null
+++ b/plugins/events/lib/index.js
@@ -0,0 +1,85 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Skywriter.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Patrick Walton (pwalton@mozilla.com)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+define(function(require, exports, module) {
+    
+exports.init = function() {
+};
+
+exports.deinit = function() {
+};
+
+exports.Event = function() {
+    var handlers = [];
+    var evt = function() {
+        var args = arguments;
+        handlers.forEach(function(handler) { handler.func.apply(null, args); });
+    };
+
+    /**
+     * Adds a new handler via
+     *  a) evt.add(handlerFunc)
+     *  b) evt.add(reference, handlerFunc)
+     */
+    evt.add = function() {
+        if (arguments.length == 1) {
+            handlers.push({
+                ref: arguments[0],
+                func: arguments[0]
+            });
+        } else {
+            handlers.push({
+                ref: arguments[0],
+                func: arguments[1]
+            });
+        }
+    };
+
+    evt.remove = function(ref) {
+        var notEqual = function(other) { return ref !== other.ref; };
+        handlers = handlers.filter(notEqual);
+    };
+
+    evt.removeAll = function() {
+        handlers = [];
+    };
+
+    return evt;
+};
+
+
+});
diff --git a/plugins/events/package.json b/plugins/events/package.json
new file mode 100644
index 0000000..a4ae216
--- /dev/null
+++ b/plugins/events/package.json
@@ -0,0 +1,4 @@
+{
+    "description": "Dead simple event implementation",
+    "dependencies": { "traits": "0.0" }
+}
\ No newline at end of file
diff --git a/plugins/events/tests/test.js b/plugins/events/tests/test.js
new file mode 100644
index 0000000..4a30237
--- /dev/null
+++ b/plugins/events/tests/test.js
@@ -0,0 +1,112 @@
+require.def(['require', 'exports', 'module',
+    'events/tests/plugindev',
+    'events/tests/events'
+], function(require, exports, module,
+    t,
+    events
+) {
+
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Skywriter.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Skywriter Team (skywriter@mozilla.com)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+
+var Event = events.Event;
+
+exports.testEventsAreCallable = function() {
+    var evt = new Event();
+    evt();
+    t.ok(true, "events are callable");
+};
+
+exports.testAddingEvents = function() {
+    var evt = new Event();
+    var run1 = false, run2 = false, run3 = false;
+    evt.add(function() { run1 = true; });
+    evt.add(function() { run2 = true; });
+    evt();
+    t.ok(run1, "run1 handler was run");
+    t.ok(run2, "run2 handler was run");
+
+    run1 = false, run2 = false, run3 = false;
+    evt.add(function() { run3 = true; });
+    evt();
+    t.ok(run1, "run1 handler was run");
+    t.ok(run2, "run2 handler was run");
+    t.ok(run3, "run3 handler was run");
+};
+
+exports.testRemovingEvents = function() {
+    var evt = new Event();
+    var ref = { hello: 'world' };
+    var run1 = false, run2 = false, run3 = false;
+    var callback1 = function() { run1 = true; };
+    var callback2 = function() { run2 = true; };
+    var callback3 = function() { run3 = true; };
+
+    evt.add(callback1);
+    evt.add(callback2);
+    evt.remove(callback1);
+    evt();
+    t.equal(run1, false, "run1 handler was not run after removed");
+    t.equal(run2, true, "run2 handler was run after run1 was removed");
+
+    run1 = false, run2 = false, run3 = false;
+    evt.add(callback3);
+    evt.remove(callback2);
+    evt.remove(callback3);
+    evt();
+    t.equal(run1, false, "run1 handler was not run after all callbacks were " +
+        "removed");
+    t.equal(run2, false, "run2 handler was not run after all callbacks were " +
+        "removed");
+    t.equal(run3, false, "run3 handler was not run after all callbacks were " +
+        "removed");
+
+    run1 = false, run2 = false, run3 = false;
+    evt.add(ref, callback3);
+    evt.remove(ref);
+    evt();
+    t.equal(run1, false, "run1 handler was not run after all callbacks were " +
+        "removed");
+    t.equal(run2, false, "run2 handler was not run after all callbacks were " +
+        "removed");
+    t.equal(run3, false, "run3 handler was not run after all callbacks were " +
+        "removed");
+};
+
+
+});
diff --git a/plugins/plugins/lib/index.js b/plugins/plugins/lib/index.js
index 7654341..1b0eeab 100644
--- a/plugins/plugins/lib/index.js
+++ b/plugins/plugins/lib/index.js
@@ -37,6 +37,8 @@
 
 define(function(require, exports, module) {
 
+var Promise = require("util/promise").Promise;
+
 exports.Plugin = function(name) {
     this.name = name;
     this.initialized = false;
@@ -44,15 +46,19 @@ exports.Plugin = function(name) {
 
 exports.Plugin.prototype = {
     initialize: function() {
+        var pr = new Promise();
         if (this.initialized) {
-            return;
+            pr.resolve(this);
+            return pr;
         }
         require([this.name], function(pluginModule) {
             if (pluginModule.init) {
                 pluginModule.init();
             }
             this.initialized = true;
+            pr.resolve(this);
         }.bind(this));
+        return pr;
     }
 };
 
@@ -62,14 +68,16 @@ exports.PluginCatalog = function() {
 
 exports.PluginCatalog.prototype = {
     initializePlugins: function(pluginList) {
+        var initializationPromises = [];
         pluginList.forEach(function(pluginName) {
             var plugin = this.plugins[pluginName];
             if (plugin === undefined) {
                 plugin = new exports.Plugin(pluginName);
                 this.plugins[pluginName] = plugin;
             }
-            plugin.initialize();
+            initializationPromises.push(plugin.initialize());
         }.bind(this));
+        return Promise.group(initializationPromises);
     }
 };
 
diff --git a/plugins/settings/lib/commands.js b/plugins/settings/lib/commands.js
new file mode 100644
index 0000000..3f78183
--- /dev/null
+++ b/plugins/settings/lib/commands.js
@@ -0,0 +1,104 @@
+require.def(['require', 'exports', 'module',
+    'skywriter/plugins',
+    'settings/environment',
+    'settings/settings'
+], function(require, exports, module,
+    plugins,
+    environment,
+    settingsMod
+) {
+
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Skywriter.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Skywriter Team (skywriter@mozilla.com)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+var catalog = plugins.catalog;
+var env = environment.env;
+
+var settings = settingsMod.settings;
+
+/**
+ * 'set' command
+ */
+exports.setCommand = function(args, request) {
+    var html;
+
+    if (!args.setting) {
+        var settingsList = settings._list();
+        html = '';
+        // first sort the settingsList based on the key
+        settingsList.sort(function(a, b) {
+            if (a.key < b.key) {
+                return -1;
+            } else if (a.key == b.key) {
+                return 0;
+            } else {
+                return 1;
+            }
+        });
+
+        settingsList.forEach(function(setting) {
+            html += '<a class="setting" href="https://wiki.mozilla.org/Labs/Skywriter/Settings#' +
+                    setting.key +
+                    '" title="View external documentation on setting: ' +
+                    setting.key +
+                    '" target="_blank">' +
+                    setting.key +
+                    '</a> = ' +
+                    setting.value +
+                    '<br/>';
+        });
+    } else {
+        if (args.value === undefined) {
+            html = '<strong>' + args.setting + '</strong> = ' + settings.get(args.setting);
+        } else {
+            html = 'Setting: <strong>' + args.setting + '</strong> = ' + args.value;
+            settings.set(args.setting, args.value);
+        }
+    }
+
+    request.done(html);
+};
+
+/**
+ * 'unset' command
+ */
+exports.unsetCommand = function(args, request) {
+    settings.resetValue(args.setting);
+    request.done('Reset ' + args.setting + ' to default: ' + settings.get(args.setting));
+};
+
+});
diff --git a/plugins/settings/lib/cookie.js b/plugins/settings/lib/cookie.js
new file mode 100644
index 0000000..04b6deb
--- /dev/null
+++ b/plugins/settings/lib/cookie.js
@@ -0,0 +1,79 @@
+require.def(['require', 'exports', 'module',
+    'skywriter/util/cookie'
+], function(require, exports, module,
+    cookie
+) {
+
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Skywriter.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Skywriter Team (skywriter@mozilla.com)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+
+
+/**
+ * Save the settings in a cookie
+ * This code has not been tested since reboot
+ * @constructor
+ */
+exports.CookiePersister = function() {
+};
+
+exports.CookiePersister.prototype = {
+    loadInitialValues: function(settings) {
+        settings._loadDefaultValues().then(function() {
+            var data = cookie.get('settings');
+            settings._loadFromObject(JSON.parse(data));
+        }.bind(this));
+    },
+
+    persistValue: function(settings, key, value) {
+        try {
+            // Aggregate the settings into a file
+            var data = {};
+            settings._getSettingNames().forEach(function(key) {
+                data[key] = settings.get(key);
+            });
+
+            var stringData = JSON.stringify(data);
+            cookie.set('settings', stringData);
+        } catch (ex) {
+            console.error('Unable to JSONify the settings! ' + ex);
+            return;
+        }
+    }
+};
+
+});
diff --git a/plugins/settings/lib/index.js b/plugins/settings/lib/index.js
new file mode 100644
index 0000000..681d7d6
--- /dev/null
+++ b/plugins/settings/lib/index.js
@@ -0,0 +1,489 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Skywriter.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Joe Walker (jwalker@mozilla.com)
+ *   Julian Viereck (jviereck@mozilla.com)
+ *   Kevin Dangoor (kdangoor@mozilla.com)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+/**
+ * This plug-in manages settings.
+ *
+ * <p>Some quick terminology: A _Choice_, is something that the application
+ * offers as a way to customize how it works. For each _Choice_ there will be
+ * a number of _Options_ but ultimately the user will have a _Setting_ for each
+ * _Choice_. This _Setting_ maybe the default for that _Choice_.
+ *
+ * <p>It provides an API for controlling the known settings. This allows us to
+ * provide better GUI/CLI support. See setting.js
+ * <p>It provides 3 implementations of a setting store:<ul>
+ * <li>MemorySettings: i.e. temporary, non-persistent. Useful in textarea
+ * replacement type scenarios. See memory.js
+ * <li>CookieSettings: Stores the data in a cookie. Generally not practical as
+ * it slows client server communication (if any). See cookie.js
+ * <li>ServerSettings: Stores data on a server using the <tt>server</tt> API.
+ * See server.js
+ * </ul>
+ * <p>It is expected that an HTML5 storage option will be developed soon. This
+ * plug-in did contain a prototype Gears implementation, however this was never
+ * maintained, and has been deleted due to bit-rot.
+ * <p>This plug-in also provides commands to manipulate the settings from the
+ * command_line and canon plug-ins.
+ *
+ * <p>TODO:<ul>
+ * <li>Check what happens when we alter settings from the UI
+ * <li>Ensure that values can be bound in a SC sense
+ * <li>Convert all subscriptions to bindings.
+ * <li>Implement HTML5 storage option
+ * <li>Make all settings have a 'description' member and use that in set|unset
+ * commands.
+ * <li>When the command system is re-worked to include more GUI interaction,
+ * expose data in settings to that system.
+ * </ul>
+ *
+ * <p>For future versions of the API it might be better to decrease the
+ * dependency on settings, and increase it on the system with a setting.
+ * e.g. Now:
+ * <pre>
+ * setting.addSetting({ name:'foo', ... });
+ * settings.set('foo', 'bar');
+ * </pre>
+ * <p>Vs the potentially better:
+ * <pre>
+ * var foo = setting.addSetting({ name:'foo', ... });
+ * foo.value = 'bar';
+ * </pre>
+ * <p>Comparison:
+ * <ul>
+ * <li>The latter version gains by forcing access to the setting to be through
+ * the plug-in providing it, so there wouldn't be any hidden dependencies.
+ * <li>It's also more compact.
+ * <li>It could provide access to to other methods e.g. <tt>foo.reset()</tt>
+ * and <tt>foo.onChange(function(val) {...});</tt> (but see SC binding)
+ * <li>On the other hand dependencies are so spread out right now that it's
+ * probably hard to do this easily. We should move to this in the future.
+ * </ul>
+ */
+
+define(function(require, exports, module) {
+
+var console = require("util/console");
+var types = require("types");
+var Event = require("events").Event;
+
+exports.init = function() {
+    // TODO add extension point in new style
+    // catalog.addExtensionPoint("setting", {
+    //     "description":
+    //         "A setting is something that the application offers as a way to customize how it works",
+    //     "register": "index#addSetting",
+    //     "indexOn": "name"
+    // });
+    // catalog.addExtensionPoint("settingChange", {
+    //     "description":
+    //         "A settingChange is a way to be notified of changes to a setting"
+    // });
+    
+    // TODO add commands in new style
+    // catalog.connect("command", module.id, {
+    //     "name": "set",
+    //     "params": [
+    //         {
+    //             "name": "setting",
+    //             "type": {
+    //                 "name": "selection",
+    //                 "pointer": "settings:index#getSettings"
+    //             },
+    //             "description": "The name of the setting to display or alter",
+    //             "defaultValue": null
+    //         },
+    //         {
+    //             "name": "value",
+    //             "type": {
+    //                 "name": "deferred",
+    //                 "pointer": "settings:index#getTypeSpecFromAssignment"
+    //             },
+    //             "description": "The new value for the chosen setting",
+    //             "defaultValue": null
+    //         }
+    //     ],
+    //     "description": "define and show settings",
+    //     "pointer": "commands#setCommand"
+    // });
+    // catalog.connect("command", module.id, {
+    //     "name": "unset",
+    //     "params": [
+    //         {
+    //             "name": "setting",
+    //             "type": {
+    //                 "name": "selection",
+    //                 "pointer": "settings:index#getSettings"
+    //             },
+    //             "description": "The name of the setting to return to defaults"
+    //         }
+    //     ],
+    //     "description": "unset a setting entirely",
+    //     "pointer": "commands#unsetCommand"
+    // });
+};
+
+exports.destroy = function() {
+};
+
+var settings = {};
+
+/**
+ * Find and configure the settings object.
+ * @see MemorySettings.addSetting()
+ */
+exports.addSetting = function(settingExt) {
+    settings[settingExt.name] = settingExt;
+    exports.settings.addSetting(settingExt);
+};
+
+/**
+ * Fetch an array of the currently known settings
+ */
+exports.getSettingNames = function() {
+    return Object.keys(settings);
+};
+
+exports.removeSetting = function(name) {
+    delete settings[name];
+};
+
+exports.getSetting = function(name) {
+    return settings[name];
+};
+
+/**
+ * Event that tells people when a setting has changed.
+ */
+exports.settingChange = new Event();
+
+
+/**
+ * Something of a hack to allow the set command to give a clearer definition
+ * of the type to the command line.
+ */
+exports.getTypeSpecFromAssignment = function(typeSpec) {
+    var assignments = typeSpec.assignments;
+    var replacement = 'text';
+
+    if (assignments) {
+        // Find the assignment for 'setting' so we can get it's value
+        var settingAssignment = null;
+        assignments.forEach(function(assignment) {
+            if (assignment.param.name === 'setting') {
+                settingAssignment = assignment;
+            }
+        });
+
+        if (settingAssignment) {
+            var settingName = settingAssignment.value;
+            if (settingName && settingName !== '') {
+                var settingExt = settings[settingName];
+                if (settingExt) {
+                    replacement = settingExt.type;
+                }
+            }
+        }
+    }
+
+    return replacement;
+};
+
+/**
+ * A base class for all the various methods of storing settings.
+ * <p>Usage:
+ * <pre>
+ * // Create manually, or require 'settings' from the container.
+ * // This is the manual version:
+ * var settings = plugins.catalog.getObject('settings');
+ * // Add a new setting
+ * settings.addSetting({ name:'foo', ... });
+ * // Display the default value
+ * alert(settings.get('foo'));
+ * // Alter the value, which also publishes the change etc.
+ * settings.set('foo', 'bar');
+ * // Reset the value to the default
+ * settings.resetValue('foo');
+ * </pre>
+ * @class
+ */
+exports.MemorySettings = function() {
+    /**
+     * Storage for the setting values
+     */
+    this._values = {};
+    
+    /**
+     * Storage for deactivated values
+     */
+    this._deactivated = {};
+};
+
+exports.MemorySettings.prototype = {
+    /**
+     * A Persister is able to store settings. It is an object that defines
+     * two functions:
+     * loadInitialValues(settings) and persistValue(settings, key, value).
+     */
+    setPersister: function(persister) {
+        this._persister = persister;
+        if (persister) {
+            persister.loadInitialValues(this);
+        }
+    },
+
+    /**
+     * Read accessor
+     */
+    get: function(key) {
+        return this._values[key];
+    },
+
+    /**
+     * Override observable.set(key, value) to provide type conversion and
+     * validation.
+     */
+    set: function(key, value) {
+        var settingExt = settings[key];
+        if (!settingExt) {
+            // If there is no definition for this setting, then warn the user
+            // and store the setting in raw format. If the setting gets defined,
+            // the addSetting() function is called which then takes up the
+            // here stored setting and calls set() to convert the setting.
+            console.warn('Setting not defined: ', key, value);
+            this._deactivated[key] = value;
+        }
+        else if (typeof value == 'string' && settingExt.type == 'string') {
+            // no conversion needed
+            this._values[key] = value;
+        }
+        else {
+            try {
+                var converted = types.fromString(value, settingExt.type);
+                inline = true;
+                this._values[key] = converted;
+
+                // Inform subscriptions of the change
+                exports.settingChange(key, converted);
+                
+            } catch (ex) {
+                console.error('Error setting', key, ': ', ex);
+            }
+        }
+
+        this._persistValue(key, value);
+        return this;
+    },
+
+    /**
+     * Function to add to the list of available settings.
+     * <p>Example usage:
+     * <pre>
+     * var settings = plugins.catalog.getObject('settings');
+     * settings.addSetting({
+     *     name: 'tabsize', // For use in settings.get('X')
+     *     type: 'number',  // To allow value checking.
+     *     defaultValue: 4  // Default value for use when none is directly set
+     * });
+     * </pre>
+     * @param {object} settingExt Object containing name/type/defaultValue members.
+     */
+    addSetting: function(settingExt) {
+        if (!settingExt.name) {
+            console.error('Setting.name == undefined. Ignoring.', settingExt);
+            return;
+        }
+
+        if (!settingExt.defaultValue === undefined) {
+            console.error('Setting.defaultValue == undefined', settingExt);
+        }
+
+        var valid = types.isValid(settingExt.defaultValue, settingExt.type);
+        try {
+            if (!valid) {
+                console.warn('!Setting.isValid(Setting.defaultValue)', settingExt);
+            }
+
+            // The value can be
+            // 1) the value of a setting that is not activated at the moment
+            //       OR
+            // 2) the defaultValue of the setting.
+            var value = this._deactivated[settingExt.name] ||
+                    settingExt.defaultValue;
+
+            // Set the default value up.
+            this.set(settingExt.name, value);
+        } catch (ex) {
+            console.error('Type error ', ex, ' ignoring setting ', settingExt);
+        }
+    },
+
+    /**
+     * Reset the value of the <code>key</code> setting to it's default
+     */
+    resetValue: function(key) {
+        var settingExt = exports.getSetting(key);
+        if (settingExt) {
+            this.set(key, settingExt.defaultValue);
+        } else {
+            console.log('ignore resetValue on ', key);
+        }
+    },
+
+    resetAll: function() {
+        exports.getSettingNames().forEach(function(key) {
+            this.resetValue(key);
+        }.bind(this));
+    },
+
+    /**
+     * Retrieve a list of the known settings and their values
+     */
+    _list: function() {
+        var reply = [];
+        exports.getSettingNames().forEach(function(setting) {
+            reply.push({
+                'key': setting,
+                'value': this.get(setting)
+            });
+        }.bind(this));
+        return reply;
+    },
+
+    /**
+     * delegates to the persister. no-op if there's no persister.
+     */
+    _persistValue: function(key, value) {
+        var persister = this._persister;
+        if (persister) {
+            persister.persistValue(this, key, value);
+        }
+    },
+
+    /**
+     * Delegates to the persister, otherwise sets up the defaults if no
+     * persister is available.
+     */
+    _loadInitialValues: function() {
+        var persister = this._persister;
+        if (persister) {
+            persister.loadInitialValues(this);
+        } else {
+            this._loadDefaultValues();
+        }
+    },
+
+    /**
+     * Prime the local cache with the defaults.
+     */
+    _loadDefaultValues: function() {
+        return this._loadFromObject(this._defaultValues());
+    },
+
+    /**
+     * Utility to load settings from an object
+     */
+    _loadFromObject: function(data) {
+        var promises = [];
+        // take the promise action out of the loop to avoid closure problems
+        var setterFactory = function(keyName) {
+            return function(value) {
+                this.set(keyName, value);
+            };
+        };
+
+        for (var key in data) {
+            if (data.hasOwnProperty(key)) {
+                var valueStr = data[key];
+                var settingExt = exports.getSetting(key);
+                if (settingExt) {
+                    // TODO: We shouldn't just ignore values without a setting
+                    var promise = types.fromString(valueStr, settingExt.type);
+                    var setter = setterFactory(key);
+                    promise.then(setter);
+                    promises.push(promise);
+                }
+            }
+        }
+
+        // Promise.group (a.k.a groupPromises) gives you a list of all the data
+        // in the grouped promises. We don't want that in case we change how
+        // this works with ignored settings (see above).
+        // So we do this to hide the list of promise resolutions.
+        var replyPromise = new Promise();
+        Promise.group(promises).then(function() {
+            replyPromise.resolve();
+        });
+        return replyPromise;
+    },
+
+    /**
+     * Utility to grab all the settings and export them into an object
+     */
+    _saveToObject: function() {
+        var promises = [];
+        var reply = {};
+
+        exports.getSettingNames().forEach(function(key) {
+            var value = this.get(key);
+            var settingExt = exports.getSetting(key);
+            if (settingExt) {
+                // TODO: We shouldn't just ignore values without a setting
+                reply[key] = types.toString(value, settingExt.type);
+            }
+        }.bind(this));
+        
+        return reply;
+    },
+
+    /**
+     * The default initial settings
+     */
+    _defaultValues: function() {
+        var defaultValues = {};
+        exports.getSettingNames.forEach(function(settingName) {
+            var settingExt = exports.getSetting(settingName);
+            defaultValues[settingExt.name] = settingExt.defaultValue;
+        });
+        return defaultValues;
+    }
+};
+
+exports.settings = new exports.MemorySettings();
+
+});
diff --git a/plugins/settings/package.json b/plugins/settings/package.json
new file mode 100644
index 0000000..25de588
--- /dev/null
+++ b/plugins/settings/package.json
@@ -0,0 +1,5 @@
+{
+    "description": "Infrastructure and commands for managing user preferences",
+    "dependencies": { "types": "0.0" },
+    "share": true
+}
\ No newline at end of file
diff --git a/plugins/types/lib/basic.js b/plugins/types/lib/basic.js
index 5420b47..0a0119d 100644
--- a/plugins/types/lib/basic.js
+++ b/plugins/types/lib/basic.js
@@ -38,7 +38,7 @@
 
 define(function(require, exports, module) {
 
-var console = require("util/console");
+var console = require("util/console").console;
     
 /**
  * These are the basic types that we accept. They are vaguely based on the
diff --git a/plugins/types/lib/index.js b/plugins/types/lib/index.js
index 47d9f66..93bd89f 100644
--- a/plugins/types/lib/index.js
+++ b/plugins/types/lib/index.js
@@ -50,6 +50,45 @@ exports.getType = function(name) {
     return typeRegistry[name];
 };
 
+var resolveType = function(typeSpec) {
+  if (typeof typeSpec === 'string') {
+      typeSpec = {name: typeSpec};
+  }
+  var type = exports.getType(typeSpec.name);
+  if (!type) {
+      throw new Error("Unknown type: " + typeSpec.name);
+  }
+  typeSpec.type = type;
+  return typeSpec;
+};
+
+/**
+ * Convert some data from a string to another type as specified by
+ * <tt>typeSpec</tt>.
+ */
+exports.fromString = function(stringVersion, typeSpec) {
+    var typeData = resolveType(typeSpec);
+    return typeData.type.fromString(stringVersion, typeSpec);
+};
+
+/**
+ * Convert some data from an original type to a string as specified by
+ * <tt>typeSpec</tt>.
+ */
+exports.toString = function(objectVersion, typeSpec) {
+    var typeData = resolveType(typeSpec);
+    return typeData.type.toString(objectVersion, typeSpec);
+};
+
+/**
+ * Convert some data from an original type to a string as specified by
+ * <tt>typeSpec</tt>.
+ */
+exports.isValid = function(originalVersion, typeSpec) {
+    var typeData = resolveType(typeSpec);
+    return typeData.type.isValid(originalVersion, typeSpec);
+};
+
 exports.init = function() {
     // TODO: register this extension point.
     
diff --git a/plugins/types/lib/types.js b/plugins/types/lib/types.js
index 9fbc358..6b1080e 100644
--- a/plugins/types/lib/types.js
+++ b/plugins/types/lib/types.js
@@ -1,3 +1,7 @@
+// TODO this file can likely be deleted. The useful functionality has moved to
+// index.js
+
+
 /* ***** BEGIN LICENSE BLOCK *****
  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
  *
@@ -37,6 +41,7 @@
 define(function(require, exports, module) {
 
 var console = require("util/console");
+var types = require("types/index");
 
 // TODO: this file needs to have the lazy loading code removed
 
@@ -207,11 +212,8 @@ exports.resolveType = function(typeSpec) {
  * <tt>typeSpec</tt>.
  */
 exports.fromString = function(stringVersion, typeSpec) {
-    var promise = new Promise();
-    exports.resolveType(typeSpec).then(function(typeData) {
-        promise.resolve(typeData.type.fromString(stringVersion, typeData.ext));
-    });
-    return promise;
+    var typeData = resolveType(typeSpec);
+    return typeData.type.fromString(stringVersion, typeData.ext);
 };
 
 /**
diff --git a/plugins/util/lib/promise.js b/plugins/util/lib/promise.js
new file mode 100644
index 0000000..60803c2
--- /dev/null
+++ b/plugins/util/lib/promise.js
@@ -0,0 +1,264 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Skywriter.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Joe Walker (jwalker@mozilla.com)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+define(function(require, exports, module) {
+
+var console = require("util/console");
+var Trace = require('util/stacktrace').Trace;
+
+/**
+ * A promise can be in one of 2 states.
+ * The ERROR and SUCCESS states are terminal, the PENDING state is the only
+ * start state.
+ */
+var ERROR = -1;
+var PENDING = 0;
+var SUCCESS = 1;
+
+/**
+ * We give promises and ID so we can track which are outstanding
+ */
+var _nextId = 0;
+
+/**
+ * Debugging help if 2 things try to complete the same promise.
+ * This can be slow (especially on chrome due to the stack trace unwinding) so
+ * we should leave this turned off in normal use.
+ */
+var _traceCompletion = false;
+
+/**
+ * Outstanding promises. Handy list for debugging only.
+ */
+var _outstanding = [];
+
+/**
+ * Recently resolved promises. Also for debugging only.
+ */
+var _recent = [];
+
+/**
+ * Create an unfulfilled promise
+ */
+Promise = function () {
+    this._status = PENDING;
+    this._value = undefined;
+    this._onSuccessHandlers = [];
+    this._onErrorHandlers = [];
+
+    // Debugging help
+    this._id = _nextId++;
+    //this._createTrace = new Trace(new Error());
+    _outstanding[this._id] = this;
+};
+
+/**
+ * Yeay for RTTI.
+ */
+Promise.prototype.isPromise = true;
+
+/**
+ * Have we either been resolve()ed or reject()ed?
+ */
+Promise.prototype.isComplete = function() {
+    return this._status != PENDING;
+};
+
+/**
+ * Have we resolve()ed?
+ */
+Promise.prototype.isResolved = function() {
+    return this._status == SUCCESS;
+};
+
+/**
+ * Have we reject()ed?
+ */
+Promise.prototype.isRejected = function() {
+    return this._status == ERROR;
+};
+
+/**
+ * Take the specified action of fulfillment of a promise, and (optionally)
+ * a different action on promise rejection.
+ */
+Promise.prototype.then = function(onSuccess, onError) {
+    if (typeof onSuccess === 'function') {
+        if (this._status === SUCCESS) {
+            onSuccess.call(null, this._value);
+        } else if (this._status === PENDING) {
+            this._onSuccessHandlers.push(onSuccess);
+        }
+    }
+
+    if (typeof onError === 'function') {
+        if (this._status === ERROR) {
+            onError.call(null, this._value);
+        } else if (this._status === PENDING) {
+            this._onErrorHandlers.push(onError);
+        }
+    }
+
+    return this;
+};
+
+/**
+ * Like then() except that rather than returning <tt>this</tt> we return
+ * a promise which
+ */
+Promise.prototype.chainPromise = function(onSuccess) {
+    var chain = new Promise();
+    chain._chainedFrom = this;
+    this.then(function(data) {
+        try {
+            chain.resolve(onSuccess(data));
+        } catch (ex) {
+            chain.reject(ex);
+        }
+    }, function(ex) {
+        chain.reject(ex);
+    });
+    return chain;
+};
+
+/**
+ * Supply the fulfillment of a promise
+ */
+Promise.prototype.resolve = function(data) {
+    return this._complete(this._onSuccessHandlers, SUCCESS, data, 'resolve');
+};
+
+/**
+ * Renege on a promise
+ */
+Promise.prototype.reject = function(data) {
+    return this._complete(this._onErrorHandlers, ERROR, data, 'reject');
+};
+
+/**
+ * Internal method to be called on resolve() or reject().
+ * @private
+ */
+Promise.prototype._complete = function(list, status, data, name) {
+    // Complain if we've already been completed
+    if (this._status != PENDING) {
+        console.group('Promise already closed');
+        console.error('Attempted ' + name + '() with ', data);
+        console.error('Previous status = ', this._status,
+                ', previous value = ', this._value);
+        console.trace();
+
+        if (this._completeTrace) {
+            console.error('Trace of previous completion:');
+            this._completeTrace.log(5);
+        }
+        console.groupEnd();
+        return this;
+    }
+
+    if (_traceCompletion) {
+        this._completeTrace = new Trace(new Error());
+    }
+
+    this._status = status;
+    this._value = data;
+
+    // Call all the handlers, and then delete them
+    list.forEach(function(handler) {
+        handler.call(null, this._value);
+    }, this);
+    this._onSuccessHandlers.length = 0;
+    this._onErrorHandlers.length = 0;
+
+    // Remove the given {promise} from the _outstanding list, and add it to the
+    // _recent list, pruning more than 20 recent promises from that list.
+    delete _outstanding[this._id];
+    _recent.push(this);
+    while (_recent.length > 20) {
+        _recent.shift();
+    }
+
+    return this;
+};
+
+/**
+ * Takes an array of promises and returns a promise that that is fulfilled once
+ * all the promises in the array are fulfilled
+ * @param group The array of promises
+ * @return the promise that is fulfilled when all the array is fulfilled
+ */
+Promise.group = function(promiseList) {
+    if (!(promiseList instanceof Array)) {
+        promiseList = Array.prototype.slice.call(arguments);
+    }
+
+    // If the original array has nothing in it, return now to avoid waiting
+    if (promiseList.length === 0) {
+        return new Promise().resolve([]);
+    }
+
+    var groupPromise = new Promise();
+    var results = [];
+    var fulfilled = 0;
+
+    var onSuccessFactory = function(index) {
+        return function(data) {
+            results[index] = data;
+            fulfilled++;
+            // If the group has already failed, silently drop extra results
+            if (groupPromise._status !== ERROR) {
+                if (fulfilled === promiseList.length) {
+                    groupPromise.resolve(results);
+                }
+            }
+        };
+    };
+
+    promiseList.forEach(function(promise, index) {
+        var onSuccess = onSuccessFactory(index);
+        var onError = groupPromise.reject.bind(groupPromise);
+        promise.then(onSuccess, onError);
+    });
+
+    return groupPromise;
+};
+
+exports.Promise = Promise;
+exports._outstanding = _outstanding;
+exports._recent = _recent;
+
+});
diff --git a/plugins/util/lib/stacktrace.js b/plugins/util/lib/stacktrace.js
new file mode 100644
index 0000000..a36519c
--- /dev/null
+++ b/plugins/util/lib/stacktrace.js
@@ -0,0 +1,332 @@
+define(function(require, exports, module) {
+    
+var util = require("util/util");
+var console = require('util/console');
+
+// Changed to suit the specific needs of running within Skywriter
+
+// Domain Public by Eric Wendelin http://eriwen.com/ (2008)
+//                  Luke Smith http://lucassmith.name/ (2008)
+//                  Loic Dachary <loic@dachary.org> (2008)
+//                  Johan Euphrosine <proppy@aminche.com> (2008)
+//                  Ã˜yvind Sean Kinsey http://kinsey.no/blog
+//
+// Information and discussions
+// http://jspoker.pokersource.info/skin/test-printstacktrace.html
+// http://eriwen.com/javascript/js-stack-trace/
+// http://eriwen.com/javascript/stacktrace-update/
+// http://pastie.org/253058
+// http://browsershots.org/http://jspoker.pokersource.info/skin/test-printstacktrace.html
+//
+
+//
+// guessFunctionNameFromLines comes from firebug
+//
+// Software License Agreement (BSD License)
+//
+// Copyright (c) 2007, Parakey Inc.
+// All rights reserved.
+//
+// Redistribution and use of this software in source and binary forms, with or without modification,
+// are permitted provided that the following conditions are met:
+//
+// * Redistributions of source code must retain the above
+//   copyright notice, this list of conditions and the
+//   following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above
+//   copyright notice, this list of conditions and the
+//   following disclaimer in the documentation and/or other
+//   materials provided with the distribution.
+//
+// * Neither the name of Parakey Inc. nor the names of its
+//   contributors may be used to endorse or promote products
+//   derived from this software without specific prior
+//   written permission of Parakey Inc.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+// FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
+// IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+// OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+
+
+/**
+ * Different browsers create stack traces in different ways.
+ * <strike>Feature</strike> Browser detection baby ;).
+ */
+var mode = (function() {
+
+    // We use SC's browser detection here to avoid the "break on error"
+    // functionality provided by Firebug. Firebug tries to do the right
+    // thing here and break, but it happens every time you load the page.
+    // bug 554105
+    if (util.isMozilla) {
+        return 'firefox';
+    } else if (util.isOpera) {
+        return 'opera';
+    } else if (util.isSafari) {
+        return 'other';
+    }
+
+    // SC doesn't do any detection of Chrome at this time.
+
+    // this is the original feature detection code that is used as a
+    // fallback.
+    try {
+        (0)();
+    } catch (e) {
+        if (e.arguments) {
+            return 'chrome';
+        }
+        if (e.stack) {
+            return 'firefox';
+        }
+        if (window.opera && !('stacktrace' in e)) { //Opera 9-
+            return 'opera';
+        }
+    }
+    return 'other';
+})();
+
+/**
+ *
+ */
+function stringifyArguments(args) {
+    for (var i = 0; i < args.length; ++i) {
+        var argument = args[i];
+        if (typeof argument == 'object') {
+            args[i] = '#object';
+        } else if (typeof argument == 'function') {
+            args[i] = '#function';
+        } else if (typeof argument == 'string') {
+            args[i] = '"' + argument + '"';
+        }
+    }
+    return args.join(',');
+}
+
+/**
+ * Extract a stack trace from the format emitted by each browser.
+ */
+var decoders = {
+    chrome: function(e) {
+        var stack = e.stack;
+        if (!stack) {
+            console.log(e);
+            return [];
+        }
+        return stack.replace(/^.*?
/, '').
+                replace(/^.*?
/, '').
+                replace(/^.*?
/, '').
+                replace(/^[^\(]+?[
$]/gm, '').
+                replace(/^\s+at\s+/gm, '').
+                replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@').
+                split('
');
+    },
+
+    firefox: function(e) {
+        var stack = e.stack;
+        if (!stack) {
+            console.log(e);
+            return [];
+        }
+        // stack = stack.replace(/^.*?
/, '');
+        stack = stack.replace(/(?:
@:0)?\s+$/m, '');
+        stack = stack.replace(/^\(/gm, '{anonymous}(');
+        return stack.split('
');
+    },
+
+    // Opera 7.x and 8.x only!
+    opera: function(e) {
+        var lines = e.message.split('
'), ANON = '{anonymous}',
+            lineRE = /Line\s+(\d+).*?script\s+(http\S+)(?:.*?in\s+function\s+(\S+))?/i, i, j, len;
+
+        for (i = 4, j = 0, len = lines.length; i < len; i += 2) {
+            if (lineRE.test(lines[i])) {
+                lines[j++] = (RegExp.$3 ? RegExp.$3 + '()@' + RegExp.$2 + RegExp.$1 : ANON + '()@' + RegExp.$2 + ':' + RegExp.$1) +
+                ' -- ' +
+                lines[i + 1].replace(/^\s+/, '');
+            }
+        }
+
+        lines.splice(j, lines.length - j);
+        return lines;
+    },
+
+    // Safari, Opera 9+, IE, and others
+    other: function(curr) {
+        var ANON = '{anonymous}', fnRE = /function\s*([\w\-$]+)?\s*\(/i, stack = [], j = 0, fn, args;
+
+        var maxStackSize = 10;
+        while (curr && stack.length < maxStackSize) {
+            fn = fnRE.test(curr.toString()) ? RegExp.$1 || ANON : ANON;
+            args = Array.prototype.slice.call(curr['arguments']);
+            stack[j++] = fn + '(' + stringifyArguments(args) + ')';
+
+            //Opera bug: if curr.caller does not exist, Opera returns curr (WTF)
+            if (curr === curr.caller && window.opera) {
+                //TODO: check for same arguments if possible
+                break;
+            }
+            curr = curr.caller;
+        }
+        return stack;
+    }
+};
+
+/**
+ *
+ */
+function NameGuesser() {
+}
+
+NameGuesser.prototype = {
+
+    sourceCache: {},
+
+    ajax: function(url) {
+        var req = this.createXMLHTTPObject();
+        if (!req) {
+            return;
+        }
+        req.open('GET', url, false);
+        req.setRequestHeader('User-Agent', 'XMLHTTP/1.0');
+        req.send('');
+        return req.responseText;
+    },
+
+    createXMLHTTPObject: function() {
+	    // Try XHR methods in order and store XHR factory
+        var xmlhttp, XMLHttpFactories = [
+            function() {
+                return new XMLHttpRequest();
+            }, function() {
+                return new ActiveXObject('Msxml2.XMLHTTP');
+            }, function() {
+                return new ActiveXObject('Msxml3.XMLHTTP');
+            }, function() {
+                return new ActiveXObject('Microsoft.XMLHTTP');
+            }
+        ];
+        for (var i = 0; i < XMLHttpFactories.length; i++) {
+            try {
+                xmlhttp = XMLHttpFactories[i]();
+                // Use memoization to cache the factory
+                this.createXMLHTTPObject = XMLHttpFactories[i];
+                return xmlhttp;
+            } catch (e) {}
+        }
+    },
+
+    getSource: function(url) {
+        if (!(url in this.sourceCache)) {
+            this.sourceCache[url] = this.ajax(url).split('
');
+        }
+        return this.sourceCache[url];
+    },
+
+    guessFunctions: function(stack) {
+        for (var i = 0; i < stack.length; ++i) {
+            var reStack = /{anonymous}\(.*\)@(\w+:\/\/([-\w\.]+)+(:\d+)?[^:]+):(\d+):?(\d+)?/;
+            var frame = stack[i], m = reStack.exec(frame);
+            if (m) {
+                var file = m[1], lineno = m[4]; //m[7] is character position in Chrome
+                if (file && lineno) {
+                    var functionName = this.guessFunctionName(file, lineno);
+                    stack[i] = frame.replace('{anonymous}', functionName);
+                }
+            }
+        }
+        return stack;
+    },
+
+    guessFunctionName: function(url, lineNo) {
+        try {
+            return this.guessFunctionNameFromLines(lineNo, this.getSource(url));
+        } catch (e) {
+            return 'getSource failed with url: ' + url + ', exception: ' + e.toString();
+        }
+    },
+
+    guessFunctionNameFromLines: function(lineNo, source) {
+        var reFunctionArgNames = /function ([^(]*)\(([^)]*)\)/;
+        var reGuessFunction = /['"]?([0-9A-Za-z_]+)['"]?\s*[:=]\s*(function|eval|new Function)/;
+        // Walk backwards from the first line in the function until we find the line which
+        // matches the pattern above, which is the function definition
+        var line = '', maxLines = 10;
+        for (var i = 0; i < maxLines; ++i) {
+            line = source[lineNo - i] + line;
+            if (line !== undefined) {
+                var m = reGuessFunction.exec(line);
+                if (m) {
+                    return m[1];
+                }
+                else {
+                    m = reFunctionArgNames.exec(line);
+                }
+                if (m && m[1]) {
+                    return m[1];
+                }
+            }
+        }
+        return '(?)';
+    }
+};
+
+var guesser = new NameGuesser();
+
+var frameIgnorePatterns = [
+    /http:\/\/localhost:4020\/sproutcore.js:/
+];
+
+exports.ignoreFramesMatching = function(regex) {
+    frameIgnorePatterns.push(regex);
+};
+
+/**
+ * Create a stack trace from an exception
+ * @param ex {Error} The error to create a stacktrace from (optional)
+ * @param guess {Boolean} If we should try to resolve the names of anonymous functions
+ */
+exports.Trace = function Trace(ex, guess) {
+    this._ex = ex;
+    this._stack = decoders[mode](ex);
+
+    if (guess) {
+        this._stack = guesser.guessFunctions(this._stack);
+    }
+};
+
+/**
+ * Log to the console a number of lines (default all of them)
+ * @param lines {number} Maximum number of lines to wrote to console
+ */
+exports.Trace.prototype.log = function(lines) {
+    if (lines <= 0) {
+        // You aren't going to have more lines in your stack trace than this
+        // and it still fits in a 32bit integer
+        lines = 999999999;
+    }
+
+    var printed = 0;
+    for (var i = 0; i < this._stack.length && printed < lines; i++) {
+        var frame = this._stack[i];
+        var display = true;
+        frameIgnorePatterns.forEach(function(regex) {
+            if (regex.test(frame)) {
+                display = false;
+            }
+        });
+        if (display) {
+            console.debug(frame);
+            printed++;
+        }
+    }
+};
+
+});
diff --git a/plugins/util/lib/util.js b/plugins/util/lib/util.js
new file mode 100644
index 0000000..5faf296
--- /dev/null
+++ b/plugins/util/lib/util.js
@@ -0,0 +1,659 @@
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is Mozilla Skywriter.
+ *
+ * The Initial Developer of the Original Code is
+ * Mozilla.
+ * Portions created by the Initial Developer are Copyright (C) 2009
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *   Skywriter Team (skywriter@mozilla.com)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either the GNU General Public License Version 2 or later (the "GPL"), or
+ * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+define(function(require, exports, module) {
+    
+/**
+ * Create an object representing a de-serialized query section of a URL.
+ * Query keys with multiple values are returned in an array.
+ * <p>Example: The input "foo=bar&foo=baz&thinger=%20spaces%20=blah&zonk=blarg&"
+ * Produces the output object:
+ * <pre>{
+ *   foo: [ "bar", "baz" ],
+ *   thinger: " spaces =blah",
+ *   zonk: "blarg"
+ * }
+ * </pre>
+ * <p>Note that spaces and other urlencoded entities are correctly handled
+ * @see dojo.queryToObject()
+ * While dojo.queryToObject() is mainly for URL query strings, this version
+ * allows to specify a separator character
+ */
+exports.queryToObject = function(str, seperator) {
+    var ret = {};
+    var qp = str.split(seperator || "&");
+    var dec = decodeURIComponent;
+    qp.forEach(function(item) {
+        if (item.length) {
+            var parts = item.split("=");
+            var name = dec(parts.shift());
+            var val = dec(parts.join("="));
+            if (exports.isString(ret[name])){
+                ret[name] = [ret[name]];
+            }
+            if (Array.isArray(ret[name])){
+                ret[name].push(val);
+            } else {
+                ret[name] = val;
+            }
+        }
+    });
+    return ret;
+};
+
+/**
+ * Takes a name/value mapping object and returns a string representing a
+ * URL-encoded version of that object for use in a GET request
+ * <p>For example, given the input:
+ * <code>{ blah: "blah", multi: [ "thud", "thonk" ] }</code>
+ * The following string would be returned:
+ * <code>"blah=blah&multi=thud&multi=thonk"</code>
+ * @param map {Object} The object to convert
+ * @return {string} A URL-encoded version of the input
+ */
+exports.objectToQuery = function(map) {
+    // FIXME: need to implement encodeAscii!!
+    var enc = encodeURIComponent;
+    var pairs = [];
+    var backstop = {};
+    for (var name in map) {
+        var value = map[name];
+        if (value != backstop[name]) {
+            var assign = enc(name) + "=";
+            if (value.isArray) {
+                for (var i = 0; i < value.length; i++) {
+                    pairs.push(assign + enc(value[i]));
+                }
+            } else {
+                pairs.push(assign + enc(value));
+            }
+        }
+    }
+    return pairs.join("&");
+};
+
+/**
+ * Holds the count to keep a unique value for setTimeout
+ * @private See rateLimit()
+ */
+var nextRateLimitId = 0;
+
+/**
+ * Holds the timeouts so they can be cleared later
+ * @private See rateLimit()
+ */
+var rateLimitTimeouts = {};
+
+/**
+ * Delay calling some function to check that it's not called again inside a
+ * maxRate. The real function is called after maxRate ms unless the return
+ * value of this function is called before, in which case the clock is restarted
+ */
+exports.rateLimit = function(maxRate, scope, func) {
+    if (maxRate) {
+        var rateLimitId = nextRateLimitId++;
+
+        return function() {
+            if (rateLimitTimeouts[rateLimitId]) {
+                clearTimeout(rateLimitTimeouts[rateLimitId]);
+            }
+
+            rateLimitTimeouts[rateLimitId] = setTimeout(function() {
+                func.apply(scope, arguments);
+                delete rateLimitTimeouts[rateLimitId];
+            }, maxRate);
+        };
+    }
+};
+
+/**
+ * Return true if it is a String
+ */
+exports.isString = function(it) {
+    return (typeof it == "string" || it instanceof String);
+};
+
+/**
+ * Returns true if it is a Boolean.
+ */
+exports.isBoolean = function(it) {
+    return (typeof it == 'boolean');
+};
+
+/**
+ * Returns true if it is a Number.
+ */
+exports.isNumber = function(it) {
+    return (typeof it == 'number' && isFinite(it));
+};
+
+/**
+ * Hack copied from dojo.
+ */
+exports.isObject = function(it) {
+    return it !== undefined &&
+        (it === null || typeof it == "object" ||
+        Array.isArray(it) || exports.isFunction(it));
+};
+
+/**
+ * Is the passed object a function?
+ * From dojo.isFunction()
+ */
+exports.isFunction = (function() {
+    var _isFunction = function(it) {
+        var t = typeof it; // must evaluate separately due to bizarre Opera bug. See #8937
+        //Firefox thinks object HTML element is a function, so test for nodeType.
+        return it && (t == "function" || it instanceof Function) && !it.nodeType; // Boolean
+    };
+
+    return exports.isSafari ?
+        // only slow this down w/ gratuitious casting in Safari (not WebKit)
+        function(/*anything*/ it) {
+            if (typeof it == "function" && it == "[object NodeList]") {
+                return false;
+            }
+            return _isFunction(it); // Boolean
+        } : _isFunction;
+})();
+
+/**
+ * A la Prototype endsWith(). Takes a regex excluding the '$' end marker
+ */
+exports.endsWith = function(str, end) {
+    if (!str) {
+        return false;
+    }
+    return str.match(new RegExp(end + "$"));
+};
+
+/**
+ * A la Prototype include().
+ */
+exports.include = function(array, item) {
+    return array.indexOf(item) > -1;
+};
+
+/**
+ * Like include, but useful when you're checking for a specific
+ * property on each object in the list...
+ *
+ * Returns null if the item is not in the list, otherwise
+ * returns the index of the item.
+ */
+exports.indexOfProperty = function(array, propertyName, item) {
+    for (var i = 0; i < array.length; i++) {
+        if (array[i][propertyName] == item) {
+            return i;
+        }
+    }
+    return null;
+};
+
+/**
+ * A la Prototype last().
+ */
+exports.last = function(array) {
+    if (Array.isArray(array)) {
+        return array[array.length - 1];
+    }
+};
+
+/**
+ * Knock off any undefined items from the end of an array
+ */
+exports.shrinkArray = function(array) {
+    var newArray = [];
+
+    var stillAtBeginning = true;
+    array.reverse().forEach(function(item) {
+        if (stillAtBeginning && item === undefined) {
+            return;
+        }
+
+        stillAtBeginning = false;
+
+        newArray.push(item);
+    });
+
+    return newArray.reverse();
+};
+
+/**
+ * Create an array
+ * @param number The size of the new array to create
+ * @param character The item to put in the array, defaults to ' '
+ */
+exports.makeArray = function(number, character) {
+    if (number < 1) {
+        return []; // give us a normal number please!
+    }
+    if (!character){character = ' ';}
+
+    var newArray = [];
+    for (var i = 0; i < number; i++) {
+        newArray.push(character);
+    }
+    return newArray;
+};
+
+/**
+ * Repeat a string a given number of times.
+ * @param string String to repeat
+ * @param repeat Number of times to repeat
+ */
+exports.repeatString = function(string, repeat) {
+    var newstring = '';
+
+    for (var i = 0; i < repeat; i++) {
+        newstring += string;
+    }
+
+    return newstring;
+};
+
+/**
+ * Given a row, find the number of leading spaces.
+ * E.g. an array with the string "  aposjd" would return 2
+ * @param row The row to hunt through
+ */
+exports.leadingSpaces = function(row) {
+    var numspaces = 0;
+    for (var i = 0; i < row.length; i++) {
+        if (row[i] == ' ' || row[i] == '' || row[i] === undefined) {
+            numspaces++;
+        } else {
+            return numspaces;
+        }
+    }
+    return numspaces;
+};
+
+/**
+ * Given a row, find the number of leading tabs.
+ * E.g. an array with the string "		aposjd" would return 2
+ * @param row The row to hunt through
+ */
+exports.leadingTabs = function(row) {
+    var numtabs = 0;
+    for (var i = 0; i < row.length; i++) {
+        if (row[i] == '	' || row[i] == '' || row[i] === undefined) {
+            numtabs++;
+        } else {
+            return numtabs;
+        }
+    }
+    return numtabs;
+};
+
+/**
+ * Given a row, extract a copy of the leading spaces or tabs.
+ * E.g. an array with the string "	    	aposjd" would return an array with the
+ * string "	    	".
+ * @param row The row to hunt through
+ */
+exports.leadingWhitespace = function(row) {
+    var leading = [];
+    for (var i = 0; i < row.length; i++) {
+        if (row[i] == ' ' || row[i] == '	' || row[i] == '' || row[i] === undefined) {
+            leading.push(row[i]);
+        } else {
+            return leading;
+        }
+    }
+    return leading;
+};
+
+/**
+ * Given a camelCaseWord convert to "Camel Case Word"
+ */
+exports.englishFromCamel = function(camel) {
+    camel.replace(/([A-Z])/g, function(str) {
+        return " " + str.toLowerCase();
+    }).trim();
+};
+
+/**
+ * I hate doing this, but we need some way to determine if the user is on a Mac
+ * The reason is that users have different expectations of their key combinations.
+ *
+ * Take copy as an example, Mac people expect to use CMD or APPLE + C
+ * Windows folks expect to use CTRL + C
+ */
+exports.OS = {
+    LINUX: 'LINUX',
+    MAC: 'MAC',
+    WINDOWS: 'WINDOWS'
+};
+
+var ua = navigator.userAgent;
+var av = navigator.appVersion;
+
+/** Is the user using a browser that identifies itself as Linux */
+exports.isLinux = av.indexOf("Linux") >= 0;
+
+/** Is the user using a browser that identifies itself as Windows */
+exports.isWindows = av.indexOf("Win") >= 0;
+
+/** Is the user using a browser that identifies itself as WebKit */
+exports.isWebKit = parseFloat(ua.split("WebKit/")[1]) || undefined;
+
+/** Is the user using a browser that identifies itself as Chrome */
+exports.isChrome = parseFloat(ua.split("Chrome/")[1]) || undefined;
+
+/** Is the user using a browser that identifies itself as Mac OS */
+exports.isMac = av.indexOf("Macintosh") >= 0;
+
+/* Is this Firefox or related? */
+exports.isMozilla = av.indexOf('Gecko/') >= 0;
+
+if (ua.indexOf("AdobeAIR") >= 0) {
+    exports.isAIR = 1;
+}
+
+/**
+ * Is the user using a browser that identifies itself as Safari
+ * See also:
+ * - http://developer.apple.com/internet/safari/faq.html#anchor2
+ * - http://developer.apple.com/internet/safari/uamatrix.html
+ */
+var index = Math.max(av.indexOf("WebKit"), av.indexOf("Safari"), 0);
+if (index && !exports.isChrome) {
+    // try to grab the explicit Safari version first. If we don't get
+    // one, look for less than 419.3 as the indication that we're on something
+    // "Safari 2-ish".
+    exports.isSafari = parseFloat(av.split("Version/")[1]);
+    if (!exports.isSafari || parseFloat(av.substr(index + 7)) <= 419.3) {
+        exports.isSafari = 2;
+    }
+}
+
+if (ua.indexOf("Gecko") >= 0 && !exports.isWebKit) {
+    exports.isMozilla = parseFloat(av);
+}
+
+/**
+ * Return a exports.OS constant
+ */
+exports.getOS = function() {
+    if (exports.isMac) {
+        return exports.OS['MAC'];
+    } else if (exports.isLinux) {
+        return exports.OS['LINUX'];
+    } else {
+        return exports.OS['WINDOWS'];
+    }
+};
+
+/** Returns true if the DOM element "b" is inside the element "a". */
+if (typeof(document) !== 'undefined' && document.compareDocumentPosition) {
+    exports.contains = function(a, b) {
+        return a.compareDocumentPosition(b) & 16;
+    };
+} else {
+    exports.contains = function(a, b) {
+        return a !== b && (a.contains ? a.contains(b) : true);
+    };
+}
+
+/**
+ * Prevents propagation and clobbers the default action of the passed event
+ */
+exports.stopEvent = function(ev) {
+    ev.preventDefault();
+    ev.stopPropagation();
+};
+
+/**
+ * Create a random password of the given length (default 16 chars)
+ */
+exports.randomPassword = function(length) {
+    length = length || 16;
+    var chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890";
+    var pass = "";
+    for (var x = 0; x < length; x++) {
+        var charIndex = Math.floor(Math.random() * chars.length);
+        pass += chars.charAt(charIndex);
+    }
+    return pass;
+};
+
+/**
+ * Is the passed object free of members, i.e. are there any enumerable
+ * properties which the objects claims as it's own using hasOwnProperty()
+ */
+exports.isEmpty = function(object) {
+    for (var x in object) {
+        if (object.hasOwnProperty(x)) {
+            return false;
+        }
+    }
+    return true;
+};
+
+/**
+ * Does the name of a project indicate that it is owned by someone else
+ * TODO: This is a major hack. We really should have a File object that include
+ * separate owner information.
+ */
+exports.isMyProject = function(project) {
+    return project.indexOf("+") == -1;
+};
+
+/**
+ * Format a date as dd MMM yyyy
+ */
+exports.formatDate = function (date) {
+    if (!date) {
+        return "Unknown";
+    }
+    return date.getDate() + " " +
+        exports.formatDate.shortMonths[date.getMonth()] + " " +
+        date.getFullYear();
+};
+
+/**
+ * Month data for exports.formatDate
+ */
+exports.formatDate.shortMonths = [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ];
+
+/**
+ * Add a CSS class to the list of classes on the given node
+ */
+exports.addClass = function(node, className) {
+    var parts = className.split(/\s+/);
+    var cls = " " + node.className + " ";
+    for (var i = 0, len = parts.length, c; i < len; ++i) {
+        c = parts[i];
+        if (c && cls.indexOf(" " + c + " ") < 0) {
+            cls += c + " ";
+        }
+    }
+    node.className = cls.trim();
+};
+
+/**
+ * Remove a CSS class from the list of classes on the given node
+ */
+exports.removeClass = function(node, className) {
+    var cls;
+    if (className !== undefined) {
+        var parts = className.split(/\s+/);
+        cls = " " + node.className + " ";
+        for (var i = 0, len = parts.length; i < len; ++i) {
+            cls = cls.replace(" " + parts[i] + " ", " ");
+        }
+        cls = cls.trim();
+    } else {
+        cls = "";
+    }
+    if (node.className != cls) {
+        node.className = cls;
+    }
+};
+
+/**
+ * Add or remove a CSS class from the list of classes on the given node
+ * depending on the value of <tt>include</tt>
+ */
+exports.setClass = function(node, className, include) {
+    if (include) {
+        exports.addClass(node, className);
+    } else {
+        exports.removeClass(node, className);
+    }
+};
+
+/**
+ * Is the passed object either null or undefined (using ===)
+ */
+exports.none = function(obj) {
+    return obj === null || obj === undefined;
+};
+
+/**
+ * Creates a clone of the passed object.  This function can take just about
+ * any type of object and create a clone of it, including primitive values
+ * (which are not actually cloned because they are immutable).
+ * If the passed object implements the clone() method, then this function
+ * will simply call that method and return the result.
+ *
+ * @param object {Object} the object to clone
+ * @param deep {Boolean} do a deep clone?
+ * @returns {Object} the cloned object
+ */
+exports.clone = function(object, deep) {
+    if (Array.isArray(object) && !deep) {
+        return object.slice();
+    }
+
+    if (typeof object === 'object' || Array.isArray(object)) {
+        if (object === null) {
+            return null;
+        }
+
+        var reply = (Array.isArray(object) ? [] : {});
+        for (var key in object) {
+            if (deep && (typeof object[key] === 'object'
+                            || Array.isArray(object[key]))) {
+                reply[key] = exports.clone(object[key], true);
+            } else {
+                 reply[key] = object[key];
+            }
+        }
+        return reply;
+    }
+
+    if (object && typeof(object.clone) === 'function') {
+        return object.clone();
+    }
+
+    // That leaves numbers, booleans, undefined. Doesn't it?
+    return object;
+};
+
+
+/**
+ * Helper method for extending one object with another
+ * Copies all properties from source to target. Returns the extended target
+ * object.
+ * Taken from John Resig, http://ejohn.org/blog/javascript-getters-and-setters/.
+ */
+exports.mixin = function(a, b) {
+    for (var i in b) {
+        var g = b.__lookupGetter__(i);
+        var s = b.__lookupSetter__(i);
+
+        if (g || s) {
+            if (g) {
+                a.__defineGetter__(i, g);
+            }
+            if (s) {
+                a.__defineSetter__(i, s);
+            }
+        } else {
+            a[i] = b[i];
+        }
+    }
+
+    return a;
+};
+
+/**
+ * Basically taken from Sproutcore.
+ * Replaces the count items from idx with objects.
+ */
+exports.replace = function(arr, idx, amt, objects) {
+    return arr.slice(0, idx).concat(objects).concat(arr.slice(idx + amt));
+};
+
+/**
+ * Return true if the two frames match.  You can also pass only points or sizes.
+ * @param r1 {Rect} the first rect
+ * @param r2 {Rect} the second rect
+ * @param delta {Float} an optional delta that allows for rects that do not match exactly. Defaults to 0.1
+ * @returns {Boolean} true if rects match
+ */
+exports.rectsEqual = function(r1, r2, delta) {
+    if (!r1 || !r2) {
+        return r1 == r2;
+    }
+
+    if (!delta && delta !== 0) {
+        delta = 0.1;
+    }
+
+    if ((r1.y != r2.y) && (Math.abs(r1.y - r2.y) > delta)) {
+        return false;
+    }
+
+    if ((r1.x != r2.x) && (Math.abs(r1.x - r2.x) > delta)) {
+        return false;
+    }
+
+    if ((r1.width != r2.width) && (Math.abs(r1.width - r2.width) > delta)) {
+        return false;
+    }
+
+    if ((r1.height != r2.height) && (Math.abs(r1.height - r2.height) > delta)) {
+        return false;
+    }
+
+    return true;
+};
+
+});
diff --git a/scripts/boot.js b/scripts/boot.js
index 4460d17..4947d66 100644
--- a/scripts/boot.js
+++ b/scripts/boot.js
@@ -37,7 +37,7 @@
 
 
 require.ready(function() {
-    var knownPlugins = ["util", "types"];
+    var knownPlugins = ["util", "events", "types", "settings"];
     
     var pluginPackageInfo = [
         {
@@ -61,6 +61,26 @@ require.ready(function() {
     });
     require(["plugins"], function() {
         var pluginsModule = require("plugins");
-        pluginsModule.catalog.initializePlugins(knownPlugins);
+        pluginsModule.catalog.initializePlugins(knownPlugins).then(function() {
+            var console = require('util/console');
+            console.log('initialized!');
+            
+            // try some stuff out. TODO delete this
+            var newSetting = {
+                name: "allGood",
+                defaultValue: false,
+                type: "boolean"
+            };
+            
+            var settings = require("settings");
+            settings.addSetting(newSetting);
+            settings.settings.set("allGood", true);
+            if (!settings.settings.get("allGood")) {
+                alert("it's not all good :(");
+            } else {
+                console.log("all good!");
+            }
+        });
+        
     });
 });
diff --git a/test.html b/test.html
index 63da9c5..b8e0eb2 100644
--- a/test.html
+++ b/test.html
@@ -4,6 +4,11 @@
   </head>
   <body>
     <h1>Sanity test.</h1>
+    <script>
+      require = {
+        urlArgs: "bust=" +  (new Date()).getTime()
+      };
+    </script>
     <script src="scripts/require.js"></script>
     <script src="scripts/boot.js"></script>
   </body>
